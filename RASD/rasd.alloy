abstract sig User {}
sig Student extends User{}
sig Educator extends User{}

sig Team{
    team_mates: set Student,
    battle: one Battle
}

sig Battle{
    creator: one Educator,
    tournament: one Tournament,
    teams: set Team,
}

sig Tournament{
    creator: one Educator,
    allowed_educators: set Educator,
    battles: set Battle,
    students: set Student
}

fact CreatorIsAllowedEdcator{
    all e: Educator | all t: Tournament | t.creator = e implies e in t.allowed_educators
}

fact BattleIsPartOfTournament{
    all t: Tournament | all b: Battle | b.tournament = t iff b in t.battles
}

fact TeamIsPartOfBattle{
    all t: Team | all b: Battle | t.battle = b iff t in b.teams
}

pred CanCreateTournament[e : Educator, t: Tournament]{
    t.creator = e
}

fact AllEducatorsCanCreateTournaments {
    all e: Educator | some t:Tournament | CanCreateTournament[e,t]
}

fact BattlesCreatorsNeedToBeAllowed{
    all e: Educator | all b: Battle | b.creator = e iff e in b.tournament.allowed_educators 
}

pred CanCreateBattles[e : Educator, t:Tournament]{
    e in t.allowed_educators
}

pred CanCloseTournament[e : Educator, t:Tournament]{
    t.creator = e
}

fact StudentCanBeInTournament{
   all s: Student | some t: Tournament | s in t.students
}

pred CanJoinTeam[s: Student, t: Team]{
    all team : t.battle.teams | not s in team.team_mates
}

pred EnrollInTournament[t, tpost: Tournament, s: Student] {
    tpost.creator = t.creator
    tpost.allowed_educators = t.allowed_educators
    tpost.battles = t.battles 
    tpost.students = t.students + s
}


assert AllEducatorsCanManageTheirTournament {
    all e: Educator | some t:Tournament | CanCreateTournament[e,t] && CanCloseTournament[e,t]
}

assert AllEducatorsCanCreateBattles {
    all e: Educator | some t:Tournament | CanCreateBattles[e,t]
}

assert StudentIsOnlyInOneTeamPerBattle{
    all s: Student | all t1,t2: Team | all b: Battle | t1.battle = b && t2.battle = b && not t1 = t2 && s in t1.team_mates implies not s in t2.team_mates
}


run {} for 10